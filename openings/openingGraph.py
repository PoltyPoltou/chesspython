from kivy import base
import kivy
from kivy.lang.builder import Builder
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.relativelayout import RelativeLayout
from io import StringIO
from typing import Set, Tuple
import chess.pgn
import chess
from kivy.app import App
from kivy.uix.stencilview import StencilView
from kivy.uix.widget import Widget
from kivy.uix.label import Label
from kivy.input.motionevent import MotionEvent
from kivy.graphics.transformation import Matrix
from kivy.properties import ColorProperty, ObjectProperty, NumericProperty, BooleanProperty
Builder.load_file("kv/opening.kv")


class DynamicList:
    def __init__(self, defaultValueGen=lambda: None) -> None:
        self.lst = []
        self.defaultValueGen = defaultValueGen

    def __setitem__(self, index, value):
        if(self.is_in_range(index)):
            self.lst[index] = value
        elif(index >= len(self.lst)):
            for i in range(len(self.lst), index):
                self.lst.append(self.defaultValueGen())
            self.lst.append(value)

    def __getitem__(self, index):
        if(not self.is_in_range(index)):
            self.__setitem__(index, self.defaultValueGen())
        return self.lst[index]

    def __len__(self) -> int:
        return len(self.lst)

    def is_in_range(self, index):
        return index < len(self.lst) and index >= 0


def createOpeningGraph(baseGame: chess.pgn.Game, matrix, x=0, y=0) -> Tuple[int, int]:
    """
    recursive method that creates a matrix that represent a cool tree of moves very useful to see openings \n

    Returns: \n
        relative-to-parent-pos : the relative height of gameNode relative to y param \n
        totaloffset : height of the whole tree generated by baseGame and his children
    """
    totaloffset = 0
    flagOneToTwoBranch = False  # True if baseGame leads to two branches with height = 1
    children_positions = []
    relative_to_parent_pos = 0
    for node in baseGame.variations:
        flagOneToTwoBranch = totaloffset == 1 and len(
            baseGame.variations) == 2 and is_one_line_variation(node)
        if(flagOneToTwoBranch):
            totaloffset += 1  # in this case, we push down the second branch
        child_pos, child_size = createOpeningGraph(
            node, matrix, x+1, y + totaloffset)
        children_positions.append(child_pos+totaloffset)
        totaloffset += child_size
    if(totaloffset == 0):
        relative_to_parent_pos = 0
    elif(flagOneToTwoBranch):
        # we are putting baseGame between the two child
        relative_to_parent_pos = 1
    else:
        # we are putting baseGame in front of one of his child
        # and the chosen child is the closer of the center
        maxPos = max(children_positions)
        index = 0
        while children_positions[index] < maxPos/2:
            index += 1
        nearest_before: bool = index != 0 and (
            abs(children_positions[index-1] - maxPos/2) < abs(children_positions[index] - maxPos/2))
        relative_to_parent_pos = children_positions[index - nearest_before]
    if(not isinstance(baseGame, chess.pgn.Game)):
        # Display the baseGameLabel at the right position
        matrix[y + relative_to_parent_pos][x-1] = baseGame.san()
    if(len(baseGame.variations) > 0):
        return relative_to_parent_pos, totaloffset
    else:
        return relative_to_parent_pos, 1


class OpeningMoveLabel(Label):
    bgColor = ColorProperty()
    gameNode = ObjectProperty(rebind=True)
    selected = BooleanProperty(False)
    sizeFactor = NumericProperty()
    top_node = NumericProperty()
    box_width = NumericProperty()
    box_height = NumericProperty()
    box_left = NumericProperty()
    box_right = NumericProperty()
    box_bottom = NumericProperty()
    box_top = NumericProperty()
    line_width = NumericProperty(1.5)
    instances = set()

    def __init__(self, node,  top_node, bottom_node, sizeFactor=0.8, **kwargs):
        self.gameNode = node
        self.sizeFactor = sizeFactor
        self.top_node = top_node
        self.bottom_node = bottom_node
        self.size_hint = (None, None)
        if(not node.turn() == chess.WHITE):
            self.bgColor = (1, 1, 1)
        else:
            self.bgColor = (0.4, 0.4, 0.4)
        super().__init__(**kwargs)
        OpeningMoveLabel.instances.add(self)

    def on_selected(self, instance, value):
        if(value):
            print(self.gameNode.san())
            for label in OpeningMoveLabel.instances:
                if(label is not instance):
                    label.selected = False

    def on_touch_up(self, touch: MotionEvent):
        if(touch.button == "left" and abs(touch.dx)+abs(touch.dy) == 0):
            t_x, t_y = touch.x + self.parent.x, touch.y + self.parent.y
            t_x -= self.parent.parent.center_x
            t_y -= self.parent.parent.center_y
            t_x, t_y = t_x/self.parent.getScalingFactor(), t_y/self.parent.getScalingFactor()
            t_x += self.parent.parent.center_x
            t_y += self.parent.parent.center_y
            t_x, t_y = t_x - self.parent.x, t_y - self.parent.y
            if(self.collide_point(t_x, t_y)):
                self.selected = True
                print(self.gameNode.san())
                return True
        return super().on_touch_up(touch)


def addNode(parent: Widget, gameNode: chess.pgn.GameNode, x, y, width, height, top_node=0, bottom_node=0):
    label = OpeningMoveLabel(
        gameNode, top_node, bottom_node, color=(0, 0, 0), pos=((x+1) * width, (y+1) * height), size=(width, height))
    parent.add_widget(label)


class OpeningNavigator(RelativeLayout):
    ZOOMPERSCROLL = 0.25
    scaling = NumericProperty(1)
    active = BooleanProperty(False)

    def on_touch_move(self, touch: MotionEvent):
        if "button" in touch.profile:
            if(touch.button == 'left'):
                self.x += touch.dx / self.getScalingFactor()
                self.y += touch.dy / self.getScalingFactor()
                return True  # stop dispatching event through the widget tree
        return super().on_touch_move(touch)

    def on_touch_down(self, touch):
        if "button" in touch.profile:
            if(touch.button == "scrolldown" or touch.button == "scrollup"):
                sign = (touch.button == "scrolldown") - \
                    (touch.button == "scrollup")
                if(self.scaling == -sign):
                    self.scaling = sign
                self.scaling = self.scaling + sign * OpeningNavigator.ZOOMPERSCROLL
        return super().on_touch_down(touch)

    def getScalingFactor(self):
        return self.scaling if self.scaling > 0 else -1/self.scaling


def createOpeningGraphOnWidget(baseGame: chess.pgn.Game, scatterWidget, x=0, y=0) -> Tuple[int, int]:
    """
    recursive method that creates a matrix that represent a cool tree of moves very useful to see openings \n

    Returns: \n
        relative-to-parent-pos : the relative height of gameNode relative to y param \n
        totaloffset : height of the whole tree generated by baseGame and his children
    """
    totaloffset = 0
    flagOneToTwoBranch = False  # True if baseGame leads to two branches with height = 1
    children_positions = []
    relative_to_parent_pos = 0
    for node in baseGame.variations:
        flagOneToTwoBranch = totaloffset == 1 and len(
            baseGame.variations) == 2 and is_one_line_variation(node)
        if(flagOneToTwoBranch):
            totaloffset += 1  # in this case, we push down the second branch
        child_pos, child_size = createOpeningGraphOnWidget(
            node, scatterWidget, x+1, y + totaloffset)
        children_positions.append(child_pos+totaloffset)
        totaloffset += child_size
    if(totaloffset == 0):
        relative_to_parent_pos = 0
    elif(flagOneToTwoBranch):
        # we are putting baseGame between the two child
        relative_to_parent_pos = 1
    else:
        # we are putting baseGame in front of one of his child
        # and the chosen child is the closer of the center
        maxPos = max(children_positions)
        index = 0
        while children_positions[index] < maxPos/2:
            index += 1
        nearest_before: bool = index != 0 and (
            abs(children_positions[index-1] - maxPos/2) < abs(children_positions[index] - maxPos/2))
        relative_to_parent_pos = children_positions[index - nearest_before]
    if(not isinstance(baseGame, chess.pgn.Game)):
        # Display the baseGameLabel at the right position
        if(len(children_positions) > 1):
            addNode(scatterWidget, baseGame, x-1, y +
                    relative_to_parent_pos, 75, 75, y + children_positions[0], y + children_positions[-1])
        else:
            addNode(scatterWidget, baseGame, x-1,
                    y+relative_to_parent_pos, 75, 75)

    if(len(baseGame.variations) > 0):
        return relative_to_parent_pos, totaloffset
    else:
        return relative_to_parent_pos, 1


def is_one_line_variation(startGame: chess.pgn.GameNode):
    if(len(startGame.variations) == 1):
        return is_one_line_variation(startGame.next())
    elif(len(startGame.variations) == 0):
        return True
    else:
        return False


def printOpeningInConsole(game):
    posMatrix = DynamicList(lambda: DynamicList(lambda: ""))
    createOpeningGraph(game.game(), posMatrix)

    maxstr = 0
    for i in range(len(posMatrix)):
        for j in range(len(posMatrix[i])):
            maxstr = max(maxstr, len(posMatrix[i][j]))

    for i in range(len(posMatrix)):
        newRow = [posMatrix[i][j] + " "*(maxstr - len(posMatrix[i][j]))
                  for j in range(len(posMatrix[i]))]
        print(newRow)


def create_opening_app(opening_pgn_file="./data/WHITE_opening.txt"):
    with open(opening_pgn_file) as pgn:
        game = chess.pgn.read_game(pgn)
        app = App()
        app.root = create_opening_widget((300, 300), opening_pgn_file)
        createOpeningGraphOnWidget(game, app.root.children[0])
        app.run()


class OpeningContainer(BoxLayout, StencilView):
    def add_widget(self, widget, index=0, canvas=None):
        widget.pos = self.pos
        return super().add_widget(widget, index=index, canvas=canvas)

    def toggleactivate(self):
        self.children[0].active = not self.children[0].active
    pass


def create_opening_widget(size, opening_pgn_file="./data/WHITE_opening.txt"):
    with open(opening_pgn_file) as pgn:
        game = chess.pgn.read_game(pgn)
        widget = OpeningNavigator()
        createOpeningGraphOnWidget(game, widget)
        container = OpeningContainer(size=size)
        container.add_widget(widget)
        widget.size_hint = (None, None)
        widget.size = size
    return container


if __name__ == "__main__":
    create_opening_app("./data/WHITE_opening.txt")
